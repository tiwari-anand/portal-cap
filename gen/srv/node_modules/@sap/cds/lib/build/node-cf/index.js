const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const BuildTaskHandlerOData = require('../buildTaskHandlerOData')
const { service: { factory }, utils: { isfile: exists } } = require("../..")
const { getHanaDbModuleDescriptor, getServiceModuleDescriptor } = require('../mtaUtil')
const { BuildMessage, BuildError } = require('../util')
const { BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY, ODATA_VERSION, ODATA_VERSION_V2,
    BUILD_NODEJS_EDMX_GENERAION, BUILD_TASK_HANA, FOLDER_GEN, SEVERITY_WARNING } = require('../constants')

const DEBUG = process.env.DEBUG
const FILE_NAME_MANIFEST_YML = "manifest.yml"

class NodeCfModuleBuilder extends BuildTaskHandlerOData {
    constructor(task, buildOptions) {
        super("Node CF Module Builder", task, buildOptions)

        if (this.task.options.compileDest) {
            throw new BuildError("Option not supported - compileDest")
        }
        if (this.isStagingBuild()) {
            const srcDir = path.relative(this.buildOptions.root, this.task.src)
            // fallback if src has been defined as '.'
            this.task.dest = path.resolve(this.task.dest, srcDir || "srv")
        }
    }

    async build() {
        const { src, dest } = this.task
        const modelPaths = this.resolveModel()
        const destGen = this.isStagingBuild() ? dest : path.join(dest, FOLDER_GEN)

        if (this.env.get(ODATA_VERSION) === ODATA_VERSION_V2) {
            // log warning as nodejs is only supporting odata version V4
            this.pushMessages(new BuildMessage("OData v2 is not supported by node runtime. Make sure to define OData v2 in cds configuration.", SEVERITY_WARNING))
        }

        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log("[cds] - no model found, skip build")
            return this._result
        }
        if (DEBUG) {
            this.logger.log(`[cds] - model: ${this.stripProjectPaths(modelPaths).join(", ")}`)
        }

        const model = await this.loadModel(modelPaths)
        const extCsn = this.cds.compile.to.json(model)
        const extModel = JSON.parse(extCsn)
        this._result.csn = extModel

        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            // adding @source annotation (reference to the origin .cds source file)
            await this.write(extCsn).to(path.join(destGen, "csn.json"))

            // The option OUTPUT_MODE_RESULT_ONLY is set by mtx build_helper and used in this context to indicate that validation
            // of custom service handlers must be skiped as part of onboarding build as the custom handler functions are not part
            // of the extension respectively tenant - otherwise false possitive warnings would be logged.
            this._validateCustomServiceHandlers(extModel)
        }

        // collect and write language bundles into single i18n.json file
        await this.copyLanguageBundles(model, destGen)

        if (this.hasCdsEnvOption(BUILD_NODEJS_EDMX_GENERAION, true) || this.hasBuildOption('edmxGeneration', true)) {
            await this.compileEdmx(model, destGen)
        }

        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            await this._copyNativeContent(src, dest)

            if (!this.task.options.skipManifestGeneration) {
                await Promise.all([this._writeManifestYml(), this._writeCfIgnore()])
            }
        }
        return this._result
    }

    async clean() {
        // staging build content is deleted by BuildTaskEngine
        if (this.buildOptions.target === this.buildOptions.root) {
            // delete the entire 'task.dest' folder otherwise, for details see #constructor
            // - the value of the folder 'src' has been appended to the origin 'task.dest' dir
            let genDest = this.isStagingBuild() ? path.dirname(this.task.dest) : path.join(this.task.dest, FOLDER_GEN)
            if (DEBUG) {
                this.logger.log(`Deleting build target folder ${genDest}`)
            }
            await fs.remove(genDest)
        }
    }

    async _copyNativeContent(src, dest) {
        const regex = RegExp('\\.cds$|package\\.json|manifest\\.y.?ml')

        await super.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return true // using common filter for folders
            }
            return !regex.test(path.basename(entry))
        })

        // copy relevant content located at project root, e.g. *.js, package.json -> gen/srv
        let packageJsonCopy = false
        const handlerRoot = path.join(this.buildOptions.root, "handlers")

        await super.copyNativeContent(this.buildOptions.root, path.dirname(dest), (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return entry.startsWith(handlerRoot)
            }
            if (/\.js$/.test(entry)) {
                return true
            }
            if (/package\.json$/.test(entry) && !this.task.options.skipPackageJsonGeneration) {
                packageJsonCopy = true
                return true
            }
            return false
        })

        if (packageJsonCopy) {
            await this._filterPackageJson(path.join(path.dirname(this.task.dest), 'package.json'))
        }
    }

    /**
     * Filter file dependencies for CF deployment.<p>
     *
     * On CF, any ../file or file:... dependency is not resolvable anyways, so we can safely filter it out.
     * In CAP samples, we use these to refer to other CDS modules at build time.
     * @param {string} file
     */
    async _filterPackageJson(file) {
        function _deleteFileDependencies(deps = {}) {
            let changed = false
            Object.keys(deps).forEach(key => {
                if (typeof deps[key] === 'string' && deps[key].startsWith('.') || deps[key].startsWith('file:')) {
                    this.logger.log(`[cds] - ${this.task.for}: removing file dependency '${deps[key]}' from ${path.relative(this.buildOptions.root, file)}`)
                    delete deps[key]
                    changed = true
                }
            })
            return changed
        }
        let content = await fs.readFile(file)
        let changed = false
        if (content) {
            content = JSON.parse(content)
            changed |= _deleteFileDependencies.call(this, content.dependencies)
            changed |= _deleteFileDependencies.call(this, content.devDependencies)
        }
        if (changed) {
            await this.write(content).to(file)
        }
    }

    // this is to have a dev fast-turnaround
    async _writeCfIgnore() {
        if (this.isStagingBuild()) {
            const content = `node_modules/\n`
            await this.write(content).to(path.join(path.dirname(this.task.dest), '.cfignore'))
        }
    }

    async _writeManifestYml() {
        if (!this.isStagingBuild()) {
            return
        }

        let manifest = path.join(this.task.src, FILE_NAME_MANIFEST_YML)
        if (await fs.pathExists(manifest)) {
            // copy existing manifest to service root folder in staging area
            await this.copy(manifest).to(path.join(path.dirname(this.task.dest), FILE_NAME_MANIFEST_YML))
            return
        }
        manifest = path.join(this.task.src, 'manifest.yml')
        if (await fs.pathExists(manifest)) {
            // copy existing manifest to service root folder in staging area
            await this.copy(manifest).to(path.join(path.dirname(this.task.dest), 'manifest.yml'))
            return
        }

        // generate one...
        // check whether a hdi service binding is required
        const hanaBuildTask = this.buildOptions.tasks.find(task => task.for === BUILD_TASK_HANA)
        let hanaServiceBinding = ""

        if (hanaBuildTask) {
            const dbModuleDescriptor = await getHanaDbModuleDescriptor(this.buildOptions.root, path.basename(hanaBuildTask.src), this.logger)
            hanaServiceBinding = `      - ${dbModuleDescriptor.hdiServiceName}`
        } else if (DEBUG) {
            this.logger.log("[cds] - generating manifest.yml without HANA service binding, using sqlite database")
        }

        try {
            const srvModuleDescriptor = await getServiceModuleDescriptor(this.buildOptions.root, path.basename(this.task.src), "nodejs", this.logger)
            const MANIFEST_YML_CONTENT = `---
applications:
  - name: ${srvModuleDescriptor.appName}
    path: .
    memory: 256M
    buildpacks:
      - nodejs_buildpack
    services:
${hanaServiceBinding}`

            await this.write(MANIFEST_YML_CONTENT).to(path.join(path.dirname(this.task.dest), FILE_NAME_MANIFEST_YML))
        } catch (e) {
            if (e.name === 'YAMLSyntaxError') {
                this.logger.error("Failed to parse [mta.yaml]")
            }
            this.logger.error(e)
        }
    }

    /**
     * Validate custom service handler defined using @impl annotation.
     * Issue warning in case the handler function cannot be resolved.
     * @param {object} model
     */
    _validateCustomServiceHandlers(model) {
        const _exclude = (def) => def['@cds.serve.ignore'] || def['@cds.ignore'] || def.kind !== "service" || !def['@impl']
        this.cds.reflect(model).foreach((def) => {
            if (!_exclude(def)) {
                const file = factory.resolve(def, def['@impl'], this.buildOptions.target === this.buildOptions.root ? this.task.src : this.buildOptions.root)
                if (!exists(file)) {
                    const relFile = path.relative(this.buildOptions.root, file)
                    this.pushMessages(new BuildMessage(`Failed to resolve service implementation for ${def.name} at: ${relFile}`, SEVERITY_WARNING))
                }
            }
        })
    }
}

module.exports = NodeCfModuleBuilder
