const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const { SEVERITY_ERROR, SEVERITES } = require('./constants')

function getProperty(src, segments) {
    segments = Array.isArray(segments) ? segments : segments.split('.')
    return segments.reduce((p, n) => p && p[n], src)
}

function setProperty(src, segments, value) {
    segments = Array.isArray(segments) ? segments : segments.split('.')
    segments.reduce((p, n, idx) => {
        if (segments.length === idx + 1) {
            p[n] = value
        } else {
            if (p[n] === undefined) {
                p[n] = {}
            }
        }
        return p[n]
    }, src)
}

/**
 * Returns an array of pom.xml file paths found in the given directories.
 * @param {Array} dirs - the absolute path names to check.
 */
function readPomFilePaths(dirs) {
    return dirs.reduce((acc, dir) => {
        const file = path.join(dir, 'pom.xml')
        if (fs.existsSync(file)) {
            acc.push(file)
        }
        return acc
    }, [])
}

/**
 * Returns whether this project is a java project or not.
 * @param {Array} dirs - the absolute path names to check.
 */
function hasJavaNature(dirs) {
    return readPomFilePaths(dirs).length > 0
}

/**
 * Returns <code>true</code> if this project is an old java service-sdk project,
 * <code>false</code> if it is a java-NG project or if no pom.xml has been found.
 * @param {Array} dirs - the absolute path names to check.
 */
async function isOldJavaStack(dirs) {
    const files = readPomFilePaths(dirs)
    if (files.length > 0) {
        return (await Promise.all(files.map(async file => {
            const content = await fs.readFile(file, 'utf-8')
            return content && /<groupId>\s*com\.sap\.cloud\.servicesdk/.test(content)
        }))).some(result => result)
    }
    return false
}

/**
 * Returns a promise that resolves after all of the given promises have either resolved or rejected,
 * with an array of objects that each describes the outcome of each promise.
 *
 * @param {*} promises An iterable object, such as an Array, in which each member is a Promise.
 * @returns A pending Promise that will be asynchronously fulfilled once every promise in the specified
 * collection of promises has completed, either by successfully being fulfilled or by being rejected.
 * At that time, the returned promise's handler is passed as input an array containing the outcome of
 * each promise in the original set of promises.<br>
 * For each outcome object, a status string is present. If the status is fulfilled, then a value is present.
 * If the status is rejected, then a reason is present. The value (or reason) reflects what value each
 * promise was fulfilled (or rejected) with.
 */
function allSettled(promises) {
    let wrappedPromises = Array.from(promises).map(p =>
        Promise.resolve(p).then(
            val => ({ state: 'fulfilled', value: val }),
            err => ({ state: 'rejected', reason: err })
        )
    );
    return Promise.all(wrappedPromises);
}

function compareErrors(a, b, skipSeverity = false) {
    function eq(x, y) {
        if (x === y) {
            return 0
        } else if (x > y) {
            return 1
        }
        return -1
    }

    let rc = 0
    if (a.severity && b.severity) {
        if (!skipSeverity) {
            rc = SEVERITES.indexOf(a.severity) - SEVERITES.indexOf(b.severity)
            if (rc !== 0) {
                return rc
            }
        }
    } else if (a.severity !== undefined) {
        return 1
    } else if (b.severity !== undefined) {
        return -1
    }

    rc = eq(a.message, b.message)
    if (rc !== 0) {
        return rc
    }

    if (a.location && b.location) {
        const aend = a.location.end || a.location.start;
        const bend = b.location.end || b.location.start;

        return (eq(a.location.filename, b.location.filename) ||
            eq(a.location.start.line, b.location.start.line) ||
            eq(a.location.start.column, b.location.start.column) ||
            eq(aend.line, bend.line) ||
            eq(aend.column, bend.column))
    }
    else {
        return (!a.location ? (!b.location ? 0 : 1) : -1)
    }
}

class BuildMessage extends Error {
    constructor(message, severity = SEVERITY_ERROR) {
        super(message)
        this.name = "BuildMessage"
        this.severity = severity
    }

    toString() {
        return this.severity + ": " + this.message
    }
}

class BuildError extends BuildMessage {
    constructor(message, errors = []) {
        super(message, SEVERITY_ERROR)
        this.name = "BuildError"
        this.errors = errors
    }

    toString() {
        return this.message + '\n' + this.errors.map(m => m.toString()).join('\n')
    }
}

module.exports = {
    getProperty,
    setProperty,
    hasJavaNature,
    isOldJavaStack,
    allSettled,
    compareErrors,
    BuildMessage,
    BuildError
}
