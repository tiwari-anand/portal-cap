const { resolve, dirname } = require('path')

// harmonizing jest and mocha
const is_mocha = !global.test
const is_jest = !!global.test
if (is_jest) { // it's jest
  global.before = (msg,fn) => global.beforeAll(fn||msg)
  global.after = (msg,fn) => global.afterAll(fn||msg)
} else { // it's mocha
  global.beforeAll = global.before
  global.afterAll = global.after
  global.test = global.it
}

// eslint-disable-next-line no-global-assign
require = (mod) => {
  try { return module.require(mod) }
  catch(e) { if (e.code === 'MODULE_NOT_FOUND') throw new Error (`
    Failed to load required package '${mod}'. Please add it thru:
    npm add -D ${mod === 'chai' ? 'chai chai-as-promised chai-subset' : mod}
  `) }
}


/** @type import('axios').default */
const Axios = {} // eslint-disable-line no-unused-vars

class Test {

  static get run(){ return (new Test).run }

  /**
   * Launches a cds server with arbitrary port and returns a subclass which
   * also acts as an axios lookalike, providing methods to send requests.
   * @returns { Test & typeof Axios & {
   *  GET: typeof Axios.get
   *  PUT: typeof Axios.put
   *  POST: typeof Axios.post
   *  PATCH: typeof Axios.patch
   *  DEL: typeof Axios.delete
   * }}
   */
  run (cmd, ...args) {

    // Setting up test server
    const console = global.console, logs=[]
    const test = new Test
    const Axios = require('axios')
    const axios = Axios.create (Axios.default.defaults)
    Object.assign (test, { axios,
      GET:   test.get    = (path,...etc) => axios.get    (_local(path),...etc) .catch(_error),
      PUT:   test.put    = (path,...etc) => axios.put    (_local(path),...etc) .catch(_error),
      POST:  test.post   = (path,...etc) => axios.post   (_local(path),...etc) .catch(_error),
      PATCH: test.patch  = (path,...etc) => axios.patch  (_local(path),...etc) .catch(_error),
      DEL:   test.delete = (path,...etc) => axios.delete (_local(path),...etc) .catch(_error),
    })

    // launch cds server...
    global.before (`launching ${cmd} ${args.join(' ')}...`, done => { // NOSONAR

      const cds = require('../index'), { isdir } = cds.utils
      if (!args.length) {
        let project = cmd; cmd = 'run'
        if (isdir(project)) ; //> all fine
        // Supporting .launch (<package name>)
        else if (isdir(resolve(project))) project = resolve(project)
        else try { project = dirname (module.require.resolve(project+'/package.json')) }
        catch(e) { throw cds.error (`Cannot resolve project folder for '${project}' in '${process.cwd()}'`) }
        args.push (project, '--in-memory?')
      }

      if (!process.env.CDS_TEST_VERBOSE) global.console = { __proto__: global.console, logs,
        time: ()=>{}, timeEnd: (...args)=> logs.push(args),
        debug: (...args)=> logs.push(args),
        log: (...args)=> logs.push(args),
        warn: (...args)=> logs.push(args),
        error: (...args)=> logs.push(args),
        dump(){ for (let each of logs) console.log (...each) },
      }

      const p = cds.exec (cmd, ...args, '--port','0')
      if (p && 'catch' in p) p.catch (e => {
        if (is_mocha) console.error(e)
        done(e)
      })

      cds.once('listening', ({ server, url }) => {
        Object.assign (test,{server,url})
        done()
      })
    })

    // shutdown cds server...
    global.after (done => {
      if (global.console !== console) global.console = console
      test.server ? test.server.close (done) : done()
      process.emit('shutdown')
    })

    function _local (path) {
      if (Array.isArray(path)) path = path[0] // in case of being called with GET `...`
      if (typeof path !== 'string') throw new Error (`Argument path is expected to be a string but got ${typeof path}`)
      if (!path.startsWith('/')) throw new Error (`Argument path is expected start with a /`)
      return test.url ? test.url+path : path
    }

    function _error (e) {
      if (!e.response)  throw e
      if (!e.response.data)  throw e
      if (!e.response.data.error)  throw e
      const { code, message } = e.response.data.error
      throw new Error (code && code !== 'null' ? `${code} - ${message}` : message)
    }

    return test
  }

  /**
   * Serving projects from subfolders under the root specified by a sequence
   * of path components which are concatenated with path.resolve().
   */
  in (...paths) {
    const dir = resolve (...paths)
    if (global.cds) {
      const env = Reflect.getOwnPropertyDescriptor(global.cds,'env').value
      if (env && env._home !== dir) throw new Error (`[cds.test] - 'cds.env' was invoked before 'cds.test.in' from a different home:

        cds.env._home: ${cds.env._home}
        cds.test.in:   ${dir}

      > throwing this as tests would likely behave erratically.
      `)
    }
    const cwd = process.cwd(); global.after (() => process.chdir(cwd))
    process.chdir (dir)
    return this
  }

  /**
   * Switch on/off console log output.
   */
  verbose(v) {
    process.env.CDS_TEST_VERBOSE = v
    return this
  }

  /** Lazily loads and returns an instance of chai */
  get chai() {
    const chai = require('chai')
    chai.use (require('chai-subset'))
    chai.use (require('chai-as-promised'))
    Object.defineProperty (this, 'chai', {value:chai})
    return chai
  }
  get expect(){ return this.chai.expect }
  get assert(){ return this.chai.assert }
}


/**
 * Test kit for jest or mocha testing, which can be used statically
 * via the getters for chai, expect and assert or through a server
 * started with cds.test(...).
 * @type Test.run & Test
 */
module.exports = Object.defineProperties (Test.prototype.run, Object.getOwnPropertyDescriptors (Test.prototype))
