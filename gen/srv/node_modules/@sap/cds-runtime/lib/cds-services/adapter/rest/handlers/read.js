const cds = global.cds || require('@sap/cds/lib')

const RestRequest = require('../RestRequest')

const getData = require('../utils/data')
const getError = require('../../../../common/error')
const handleError = require('../utils/handle-error')
const { bufferToBase64 } = require('../utils/binary')

module.exports = service => {
  return async (restReq, restRes) => {
    const {
      _parsed: parsed,
      _parsed: { segments, isCollection }
    } = restReq

    const [validationError, data] = getData(parsed, restReq)
    if (validationError) return handleError(validationError, service, restReq, restRes)

    // create tx and set as cds.context
    // REVISIT: _model should not be necessary
    const tx = service.tx({ user: restReq.user, req: restReq, _model: service.model }, cds.version < '4.4')
    cds.context = tx

    const req = new RestRequest(parsed, data, restReq, restRes, service)

    let result, err, commit
    try {
      result = await tx.emit(req)

      bufferToBase64(result, segments[0])

      // REVISIT
      if (!Array.isArray(result)) result = [result]

      if (!isCollection) {
        if (result.length !== 1) {
          throw getError(404, 'NO_MATCHING_RESOURCE')
        }
        result = result[0]
      }

      commit = true
      await tx.commit(result)
    } catch (e) {
      err = e
      if (!commit) {
        // ignore rollback error, which should never happen
        await tx.rollback(e).catch(() => {})
      }
    } finally {
      if (err) {
        // Hide errors in generic message but log detailed error
        handleError(err, service, restReq, restRes)
      } else {
        restRes.send(result)
      }
    }
  }
}
