const cds = global.cds || require('@sap/cds/lib')

const {
  BatchExitHandler: { ATOMICITY_GROUP_START, ATOMICITY_GROUP_END },
  Components: {
    DATA_CREATE_HANDLER,
    DATA_DELETE_HANDLER,
    DATA_READ_HANDLER,
    DATA_UPDATE_HANDLER,
    ACTION_EXECUTE_HANDLER,
    LOCALE_NEGOTIATOR,
    METADATA_HANDLER
  }
} = require('./okra/odata-server')

const _config = require('./utils/oDataConfiguration')
const _error = require('./handlers/error')
const _debug = require('./handlers/debug')
const _request = require('./handlers/request')
const _language = require('./handlers/language')
const _metadata = require('./handlers/metadata')
const _create = require('./handlers/create')
const _update = require('./handlers/update')
const _delete = require('./handlers/delete')
const _read = require('./handlers/read')
const _action = require('./handlers/action')
const { normalizeError } = require('../../../common/error/frontend')

/**
 * Facade for creating an instance of a EDM based OData service.
 * @alias module:odata.OData
 */
class OData {
  /**
   * Constructs an OData service for the given EDM model.
   * @param {Object} edm - the EDM model.
   * @param {Object} [options] - optional object with options.
   * @param {Object} [options.logger] - optional logger object to be used in the odata library.
   * @param {string} [options.logLevel] - optional log level to be used according to winston/npm specification.
   * @param {string} [options.service] - Service name as specified in CSN.
   * @param {boolean} [options.crashOnError] - Application should crash on error. Defaults to true.
   *
   * @throws Error in case no or an invalid csn model is provided.
   */
  constructor (edm, csn, options = {}) {
    this._validateEdm(edm)
    this._options = options
    this._csn = csn
    this._createOdataService(edm)
  }

  _validateEdm (edm) {
    if (typeof edm !== 'object' || !edm.$Version) {
      const { getModelNotDefinedError } = require('../../util/errors')
      throw getModelNotDefinedError('EDM model')
    }
  }

  _createOdataService (edm) {
    const ServiceFactory = require('./okra/odata-server').ServiceFactory

    // skip okra's validation in production, via explicit skipValidation, or implicitely for w4 and x4
    // REVISIT: cds.env.effective will be there with @sap/cds^4.2
    const effective = cds.env.effective || cds.env
    const isTrusted =
      process.env.NODE_ENV === 'production' ||
      cds.env.odata.skipValidation ||
      effective.odata.structs ||
      effective.odata.refs ||
      effective.odata.proxies ||
      effective.odata.containment

    this._odataService = ServiceFactory.createService(edm, _config(edm, this._csn, this._options)).trust(isTrusted)

    // will be added to express app like app.use('/base/path/', service) and odata-v4 wants app.use('/', service) if basePath is set
    this._odataService.setBasePath('/')
  }

  /**
   * The added cds service will be used at the handlers.
   * Some channel events have a 1:N relation to service handler events.
   * @param {Service} cdsService
   */
  addCDSServiceToChannel (cdsService) {
    this._odataService.log(cdsService.logger)
    this._cdsService = cdsService

    this._odataService.on('error', _error(this._options.crashOnError))
    if (this._options.debug) this._odataService.on('debug', _debug)
    this._odataService.on('request', _request(cdsService))

    this._odataService.on(ATOMICITY_GROUP_START, (odataContext, done) => {
      const data = odataContext.applicationData
      // start tx
      const txs = (data.txs = data.txs || {})
      const {
        req: { user },
        req
      } = data
      // REVISIT: _model should not be necessary
      const tx = (txs[odataContext.id] = cdsService.tx({ user, req, _model: cdsService.model }, cds.version < '4.4'))
      cds.context = tx.context
      // for collecting results and errors
      data.results = data.results || {}
      data.results[odataContext.id] = []
      data.errors = data.errors || {}
      data.errors[odataContext.id] = []
      done()
    })

    this._odataService.on(ATOMICITY_GROUP_END, async (odataErr, odataContext, done) => {
      const tx = odataContext.applicationData.txs[odataContext.id]
      const errors = odataErr || odataContext.failedRequests.length > 0
      if (!errors) {
        try {
          await tx.commit(odataContext.applicationData.results[odataContext.id])
          done()
        } catch (e) {
          // tx gets rolled back automatically
          // set error on each request of changeset, if commit failed
          const changesetResults = odataContext.applicationData.results[odataContext.id]
          const failedRequests = changesetResults.reduce((obj, resultEntry) => {
            const requestId = resultEntry.req._.odataReq.getOdataRequestId()
            const { error, statusCode } = normalizeError(e, resultEntry.req)
            obj[requestId] = Object.assign(error, { statusCode })
            return obj
          }, {})
          done(e, { failedRequests })
        }
      } else {
        // ignore rollback error, which should never happen
        await tx.rollback(odataContext.applicationData.errors[odataContext.id]).catch(() => {})
        done()
      }
    })

    this._odataService.use(LOCALE_NEGOTIATOR, _language)
    this._odataService.use(METADATA_HANDLER, _metadata(cdsService, this._options))

    this._odataService.use(DATA_CREATE_HANDLER, _create(cdsService, this._options))
    this._odataService.use(DATA_READ_HANDLER, _read(cdsService, this._options))
    this._odataService.use(DATA_UPDATE_HANDLER, _update(cdsService, this._options))
    this._odataService.use(DATA_DELETE_HANDLER, _delete(cdsService, this._options))

    this._odataService.use(ACTION_EXECUTE_HANDLER, _action(cdsService, this._options))
  }

  // _startPerfMeasurementOData (req) {
  //   if (req.performanceMeasurement) {
  //     const uuid = req.performanceMeasurement.uuid
  //     req.performanceMeasurement.performance.mark(`${uuid} ODataIn Start`)
  //   }
  // }

  /**
   * Process request.
   * @private
   */
  process (req, res) {
    // default to combination [...];IEEE754Compatible=true;ExponentialDecimals=true if one is omitted
    if (req.headers && req.headers.accept && req.headers.accept.startsWith('application/json')) {
      if (
        req.headers.accept.includes('IEEE754Compatible=true') &&
        !req.headers.accept.includes('ExponentialDecimals')
      ) {
        req.headers.accept += ';ExponentialDecimals=true'
      }
      if (
        req.headers.accept.includes('ExponentialDecimals=true') &&
        !req.headers.accept.includes('IEEE754Compatible')
      ) {
        req.headers.accept += ';IEEE754Compatible=true'
      }
    }

    // this._startPerfMeasurementOData(req)
    this._odataService.process(req, res).catch(err => {
      // REVISIT: use i18n
      res.status(500).send({ error: { code: 'null', message: err.message } })
    })
  }
}

module.exports = OData
