const cds = global.cds || require('@sap/cds/lib')

const ODataRequest = require('../ODataRequest')

const {
  Components: { DATA_UPDATE_HANDLER, DATA_CREATE_HANDLER }
} = require('../okra/odata-server')

const { getSapMessages } = require('../../../../common/error/frontend')
const { toODataResult } = require('../utils/event')
const { validateResourcePath } = require('../utils/request')
const { removeContainmentKeys } = require('../utils/handlerUtils')
const autoExpandIfNecessary = require('../utils/autoExpandToOne')
const { getEtagElement } = require('../../../../common/utils/csn')
const readAfterWrite = require('../utils/readAfterWrite')
const { getVirtualsFromResult } = require('../utils/result')

const _addETag = (odataReq, req, result) => {
  if (odataReq.getConcurrentResource() !== null) {
    const etagElement = getEtagElement(req.target)
    result['*@odata.etag'] = result[etagElement.name]
  }
}

const { COMMON, ODATA } = require('../../../../common/constants/annotation')

const _isDraftEntity = target => {
  return (
    target &&
    (target[ODATA.DRAFT] || target[COMMON.DRAFT_NODE.PREP_ACTION] || target.name.endsWith('.DraftAdministrativeData'))
  )
}

const _isUpsertAllowed = target => {
  return !(cds.env.runtime && cds.env.runtime.allow_upsert === false) && !_isDraftEntity(target)
}

const _updateThenCreate = async (req, odataReq, odataRes, tx) => {
  let result

  try {
    result = await tx.emit(req)
  } catch (e) {
    if (e.code === 404 && _isUpsertAllowed(req.target)) {
      // REVISIT: remove error (and child?) from tx.context? -> would require a unique req.id

      req = new ODataRequest(DATA_CREATE_HANDLER, tx, odataReq, odataRes, true)
      result = await tx.emit(req)
    } else {
      throw e
    }
  }

  return [result, req]
}

const _postProcess = (odataReq, req, result, service) => {
  _addETag(odataReq, req, result)
  autoExpandIfNecessary(req.target, result)
  removeContainmentKeys(service, req.target, result)
}

/**
 * The handler that will be registered with odata-v4.
 *
 * In case of success it calls next with the number of updated entries as result.
 * In case of error it calls next with error.
 *
 * @param {Service} service
 * @param {Object} options
 * @return {Function}
 */
const update = (service, options) => {
  return async (odataReq, odataRes, next) => {
    let req
    try {
      validateResourcePath(odataReq, options, service.model)
      req = new ODataRequest(DATA_UPDATE_HANDLER, service, odataReq, odataRes)
    } catch (e) {
      return next(e)
    }

    let tx
    const changeset = odataReq.getAtomicityGroupId()
    if (changeset) {
      tx = odataReq.getBatchApplicationData().txs[changeset]
    } else {
      cds.context = tx = service.tx(req, cds.version < '4.4')
    }

    let result, err, commit
    try {
      // try UPDATE and, on 404 error, try CREATE
      ;[result, req] = await _updateThenCreate(req, odataReq, odataRes, tx)

      // REVISIT: find better solution
      if (req._.readAfterWrite) {
        const dataInDb = await readAfterWrite(req, service)
        // REVISIT: may be a problem on direct update of a property (which we don't support yet)
        // augment data in db so values of virtual properties are kept
        const virtuals = getVirtualsFromResult(req.target, result)
        result = Object.assign(dataInDb[0] || result, virtuals)
      }

      _postProcess(odataReq, req, result, service)

      if (!changeset) {
        commit = true
        await tx.commit(result)
      } else {
        // for passing into commit
        odataReq.getBatchApplicationData().results[changeset].push({ result, req })
      }
    } catch (e) {
      err = e
      if (!changeset && !commit) {
        // ignore rollback error, which should never happen
        await tx.rollback(e).catch(() => {})
      } else if (changeset) {
        // for passing into rollback
        odataReq.getBatchApplicationData().errors[changeset].push({ error: e, req })
      }
    } finally {
      req.messages && odataRes.setHeader('sap-messages', getSapMessages(req.messages, req._.req))

      if (err) next(err)
      else next(null, toODataResult(result))
    }
  }
}

module.exports = update
