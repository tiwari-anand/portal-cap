const { all, resolve } = require('../../common/utils/thenable')
const elementUtils = require('../../common/utils/element')

// REVISIT: replace with cds.Request
const getEntry = require('../../../lib/common/error/entry')

const ISO_DATE_PART1 =
  '[1-9]\\d{3}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1\\d|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)'
const ISO_DATE_PART2 = '(?:[1-9]\\d(?:0[48]|[2468][048]|[13579][26])|(?:[2468][048]|[13579][26])00)-02-29'
const ISO_DATE = `(?:${ISO_DATE_PART1}|${ISO_DATE_PART2})`
const ISO_TIME_NO_MILLIS = '(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d'
const ISO_TIME = `${ISO_TIME_NO_MILLIS}(?:\\.\\d{1,9})?`
const ISO_DATE_TIME = `${ISO_DATE}T${ISO_TIME_NO_MILLIS}(?:Z|[+-][01]\\d:?[0-5]\\d)`
const ISO_TIMESTAMP = `${ISO_DATE}T${ISO_TIME}(?:Z|[+-][01]\\d:?[0-5]\\d)`

const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
const ISO_DATE_REGEX = new RegExp(`^${ISO_DATE}$`, 'i')
const ISO_TIME_REGEX = new RegExp(`^${ISO_TIME_NO_MILLIS}$`, 'i')
const ISO_DATE_TIME_REGEX = new RegExp(`^${ISO_DATE_TIME}$`, 'i')
const ISO_TIMESTAMP_REGEX = new RegExp(`^${ISO_TIMESTAMP}$`, 'i')

const ASSERT_VALID_ELEMENT = 'ASSERT_VALID_ELEMENT'
const ASSERT_RANGE = 'ASSERT_RANGE'
const ASSERT_FORMAT = 'ASSERT_FORMAT'
const ASSERT_DATA_TYPE = 'ASSERT_DATA_TYPE'
const ASSERT_ENUM = 'ASSERT_ENUM'
const ASSERT_NOT_NULL = 'ASSERT_NOT_NULL'
const ASSERT_REFERENCE_INTEGRITY = 'ASSERT_REFERENCE_INTEGRITY'
const ASSERT_DEEP_TO_ONE_ASSOCIATION = 'ASSERT_DEEP_TO_ONE_ASSOCIATION'
const ASSERT_DEEP_TO_MANY_ASSOCIATION = 'ASSERT_DEEP_TO_MANY_ASSOCIATION'

const _enumValues = element => {
  return Object.keys(element).map(enumKey => {
    const enum_ = element[enumKey]
    const enumValue = enum_ && (enum_.val || enum_.value) // OLD CSN
    if (enumValue) {
      if (enumValue['=']) return enumValue['=']
      if (enum_ && enum_.literal && enum_.literal === 'number') return Number(enumValue)
      return enumValue
    }
    return enumKey
  })
}

const assertError = (code, element, value, key) => {
  const { name, type, precision, scale } = element

  const error = getEntry({ code, message: code, target: name, args: [name || key] })
  Object.assign(error, {
    entity: element.parent && element.parent.name,
    element: name, // > REVISIT: when is error.element needed?
    type: element.items ? element.items.type : type,
    value
  })

  if (element.enum) {
    error.enum = _enumValues(element)
  }
  if (precision) {
    error.precision = precision
  }
  if (scale) {
    error.scale = scale
  }
  if (element.target) {
    // REVISIT: when does this case apply?
    error.target = element.target
  }

  return error
}

const _checkString = value => {
  return typeof value === 'string'
}

const _checkNumber = value => {
  return typeof value === 'number'
}

const _checkDecimal = (value, element) => {
  const [left, right] = String(value).split('.')
  return (
    _checkNumber(value) &&
    (!element.precision || left.length <= element.precision - (element.scale || 0)) &&
    (!element.scale || ((right || '').length <= element.scale && parseFloat(right) !== 0))
  )
}

const _checkInteger = value => {
  return _checkNumber(value) && parseInt(value, 10) === value
}

const _checkBoolean = value => {
  return typeof value === 'boolean'
}

const _checkBuffer = value => {
  return Buffer.isBuffer(value)
}

const _checkUUID = value => {
  return _checkString(value) && UUID_REGEX.test(value)
}

const _checkISODate = value => {
  return _checkString(value) && ISO_DATE_REGEX.test(value)
}

const _checkISOTime = value => {
  return _checkString(value) && ISO_TIME_REGEX.test(value)
}

const _checkISODateTime = value => {
  return _checkString(value) && ISO_DATE_TIME_REGEX.test(value)
}

const _checkISOTimestamp = value => {
  return _checkString(value) && ISO_TIMESTAMP_REGEX.test(value)
}

const _checkInRange = (val, range) => {
  return _checkISODate(val)
    ? (new Date(val) - new Date(range[0])) * (new Date(val) - new Date(range[1])) <= 0
    : (val - range[0]) * (val - range[1]) <= 0
}

const _checkRegExpFormat = (val, format) => {
  if (_checkString(val)) {
    const match = val.match(new RegExp(format, 'g'))
    return match && match.length === 1 && match[0] === val
  }
  return false
}

const CDS_TYPE_CHECKS = {
  'cds.UUID': _checkUUID,
  'cds.Boolean': _checkBoolean,
  'cds.Integer': _checkInteger,
  'cds.Integer64': _checkInteger,
  'cds.Decimal': _checkDecimal,
  'cds.DecimalFloat': _checkNumber,
  'cds.Double': _checkNumber,
  'cds.Date': _checkISODate,
  'cds.Time': _checkISOTime,
  'cds.DateTime': _checkISODateTime,
  'cds.Timestamp': _checkISOTimestamp,
  'cds.String': _checkString,
  'cds.Binary': _checkBuffer,
  'cds.LargeString': _checkString,
  'cds.LargeBinary': _checkBuffer
}

// Limitation: depth 1
const checkComplexType = ([key, value], elements, ignoreNonModelledData) => {
  let found = false

  for (const objKey in elements) {
    if (objKey.startsWith(`${key}_`)) {
      const element = elements[objKey]
      const check = CDS_TYPE_CHECKS[element.type]
      found = true

      const nestedData = value[objKey.substring(key.length + 1)]
      // check existence of nestedData to not stumble across not-provided, yet-modelled type parts with depth > 1
      if (nestedData && !check(nestedData)) {
        return false
      }
    }
  }

  return found || ignoreNonModelledData
}

const _checkStaticElementByKey = (entity, key, value, result, ignoreNonModelledData) => {
  const element = entity.elements[key]

  if (!element) {
    if (!checkComplexType([key, value], entity.elements, ignoreNonModelledData)) {
      result.push(assertError(ASSERT_VALID_ELEMENT, { name: key }))
    }

    return result
  }

  const check = CDS_TYPE_CHECKS[element.type]

  if (check && !check(value, element)) {
    // code, entity, element, value
    result.push(assertError(ASSERT_DATA_TYPE, element, value, key))
  }

  return result
}

const _isNotFilled = value => {
  return value === null || value === undefined || (typeof value === 'string' && value.trim() === '')
}

const checkInputConstraints = (element, value, result, key) => {
  if (!element) {
    return result
  }

  // enum
  const enumElements = (element['@assert.range'] && element.enum) || element['@assert.enum'] ? element.enum : undefined
  if (enumElements && !_enumValues(enumElements).includes(value)) {
    result.push(assertError(ASSERT_ENUM, element, value, key))
  }

  // range
  const rangeElements = element['@assert.range'] && !enumElements ? element['@assert.range'] : undefined
  if (rangeElements && !_checkInRange(value, rangeElements)) {
    result.push(assertError(ASSERT_RANGE, element, value, key))
  }

  // format
  const formatElements = element['@assert.format']
  if (formatElements && !_checkRegExpFormat(value, formatElements)) {
    result.push(assertError(ASSERT_FORMAT, element, value, key))
  }

  // mandatory
  if (elementUtils.isMandatoryField(element) && !element.default && _isNotFilled(value)) {
    result.push(assertError(ASSERT_NOT_NULL, element, value, key))
  }

  return result
}

const checkStatic = (entity, data, ignoreNonModelledData = false) => {
  if (!Array.isArray(data)) {
    return checkStatic(entity, [data], ignoreNonModelledData)
  }

  return data.reduce((result, row) => {
    return Object.entries(row)
      .filter(([key, value]) => value !== null && value !== undefined)
      .reduce((result, [key, value]) => {
        return _checkStaticElementByKey(entity, key, value, result, ignoreNonModelledData)
      }, result)
  }, [])
}

const _checkExistsWhere = (entity, whereList, run) => {
  const checks = whereList.map(where => {
    if (where.length === 0) {
      return true
    }

    const cqn = {
      SELECT: {
        columns: [{ val: 1, as: '_exists' }],
        from: { ref: [entity.name || entity] },
        where: where
      }
    }

    return run(cqn).then(exists => {
      return exists.length !== 0
    })
  })

  return all(checks)
}

const _checkExists = (entity, data, context, run) => {
  if (!Array.isArray(data)) {
    return _checkExists(entity, [data], context, run).then(result => {
      return result[0]
    })
  }

  const where = data.map(row => {
    return Object.keys(entity.keys).reduce((where, name) => {
      if (row[name] !== undefined && row[name] !== null) {
        if (where.length > 0) {
          where.push('and')
        }
        where.push({ ref: [name] }, '=', { val: row[name] })
      }

      return where
    }, [])
  })
  return _checkExistsWhere(entity, where, run)
}

const _getFullForeignKeyName = (elementName, foreignKeyName) => `${elementName}_${foreignKeyName}`

const _foreignKeyReducer = (key, foreignKeyName, row, element, ref) => {
  const fullForeignKeyName = _getFullForeignKeyName(element.name, foreignKeyName)

  if (ref.length > 1) {
    // ref includes assoc name, so we need to replace it by foreign key name
    const refWithFlatForeignKey = [...ref.slice(0, ref.length - 1), fullForeignKeyName]
    key[foreignKeyName] = _getDataFromRef(row, refWithFlatForeignKey)
  } else {
    key[foreignKeyName] = row.hasOwnProperty(fullForeignKeyName) ? row[fullForeignKeyName] : null
  }

  return key
}

const _buildForeignKey = (element, row, ref) => {
  let foreignKey

  if (element.keys) {
    foreignKey = element.keys
      .map(obj => obj.ref[obj.ref.length - 1])
      .reduce((key, foreignKeyName) => {
        return _foreignKeyReducer(key, foreignKeyName, row, element, ref)
      }, {})
  }

  return foreignKey
}

const _getDataFromRef = (row, ref) => {
  if (row === undefined) return

  if (ref.length > 1) {
    return _getDataFromRef(row[ref[0]], ref.slice(1))
  }

  return row[ref[0]]
}

const _checkAssociations = (element, row, context, result, ref) => {
  const data = _getDataFromRef(row, ref)
  if ((context.event === 'CREATE' || context.event === 'UPDATE') && data !== undefined) {
    if (element.is2many && !element['@odata.contained']) {
      result.push(assertError(ASSERT_DEEP_TO_MANY_ASSOCIATION, element))
      return result
    }

    if (element.is2one && !element['@odata.contained']) {
      result.push(assertError(ASSERT_DEEP_TO_ONE_ASSOCIATION, element))
      return result
    }
  }
}

const _getElement = (entity, ref) => {
  if (ref.length > 1) {
    // structured
    return _getElement(entity.elements[ref[0]], ref.slice(1))
  }

  return entity.elements[ref[0]]
}

const _checkCreateUpdate = (result, ref, rootEntity, checks, data, context, run) => {
  const resolvedElement = _getElement(rootEntity, ref)

  return data.reduce((result, row) => {
    const assocError = _checkAssociations(resolvedElement, row, context, result, ref)
    if (assocError) return assocError

    if (resolvedElement.on) return result

    const foreignKey = _buildForeignKey(resolvedElement, row, ref)
    if (foreignKey === undefined) return result

    checks.push(
      _checkExists(resolvedElement._target, foreignKey, context, run).then(exists => {
        if (!exists) {
          result.push(assertError(ASSERT_REFERENCE_INTEGRITY, resolvedElement, foreignKey))
        }
      })
    )

    return result
  }, result)
}

const _isOnCondWith = (element, name) => {
  return element.some(el => {
    return el.ref && el.ref.includes(name)
  })
}

const _isCustomOnCond = element => {
  return element.on && !_isOnCondWith(element.on, '$self')
}

const _isManagedToOneAssoc = (element, name) => {
  return (
    element.type === 'cds.Association' &&
    !element['@odata.contained'] &&
    element.is2one &&
    element.target === name &&
    !_isCustomOnCond(element)
  )
}

const _buildWhereDelete = (result, key, element, context, data) => {
  return data
    .map(d => {
      return Object.keys(d).reduce((result, name) => {
        if (key.ref[0] === name) {
          if (result.length > 0) {
            result.push('and')
          }
          result.push({ ref: [_getFullForeignKeyName(element.name, key.ref[0])] }, '=', { val: d[name] })
        }

        return result
      }, result)
    })
    .reduce((accumulatedWhere, currentWhere, i) => {
      if (i > 0) accumulatedWhere.push('or')
      accumulatedWhere.push(...currentWhere)
      return accumulatedWhere
    }, [])
}

const _isCompBacklink = (entity, assoc) => {
  for (const element in entity.elements) {
    const targetElement = entity.elements[element]
    if (
      (targetElement.type === 'cds.Composition' || targetElement['@odata.contained']) &&
      targetElement.on &&
      _isOnCondWith(targetElement.on, assoc.name) &&
      _isOnCondWith(targetElement.on, '$self')
    ) {
      return true
    }
  }
  return false
}

const _checkDelete = (result, key, entity, checks, context, csn, run, data) => {
  const elements = csn.definitions[key].elements
  const source = csn.definitions[key].name

  return Object.keys(elements).reduce((result, assoc) => {
    if (
      _isManagedToOneAssoc(elements[assoc], entity.name) &&
      csn.definitions[key].name !== entity.name &&
      elements[assoc]['@assert.integrity'] !== false
    ) {
      if (_isCompBacklink(entity, elements[assoc])) {
        return result
      }
      const keys = elements[assoc].keys
      // In case the other entity has no reference to the entity being deleted -> no dangling key
      if (!keys) return
      const where = keys.reduce((buildWhere, key) => {
        return _buildWhereDelete(buildWhere, key, elements[assoc], context, data)
      }, [])
      checks.push(
        _checkExistsWhere(source, [where], run).then(exists => {
          if (exists.includes(true)) {
            result.push(assertError(ASSERT_REFERENCE_INTEGRITY, elements[assoc], context.data))
          }
        })
      )

      return result
    } else {
      return result
    }
  }, result)
}

function _filterStructured (element, structuredAssocs, prefix) {
  const elements = element.elements
  for (const subElement in elements) {
    if (_filterAssocs(elements[subElement], structuredAssocs, prefix)) {
      structuredAssocs.push([...prefix, elements[subElement].name])
    }
  }
}

const _filterAssocs = (element, structuredAssocs, prefix = []) => {
  if (element.elements) {
    _filterStructured(element, structuredAssocs, [...prefix, element.name])
  }

  return (
    element.type === 'cds.Association' &&
    !element.virtual &&
    !element.abstract &&
    element['@assert.integrity'] !== false &&
    !element['@odata.contained'] &&
    // REVISIT: rm target['@cds.persistence.skip'] !== 'if-unused' with cds^4.5
    (!element._target['@cds.persistence.skip'] || element._target['@cds.persistence.skip'] === 'if-unused')
  )
}

const checkReferenceIntegrity = (entity, data, context, csn, run) => {
  if (!Array.isArray(data)) data = [data]

  const checks = []
  let result
  if (context.event === 'CREATE' || context.event === 'UPDATE') {
    const structuredAssocRefs = []
    const associationRefs = Object.keys(entity.elements)
      .filter(elementName => _filterAssocs(entity.elements[elementName], structuredAssocRefs))
      .map(name => [name])
    result = [...associationRefs, ...structuredAssocRefs].reduce((createUpdateResult, ref) => {
      return _checkCreateUpdate(createUpdateResult, ref, entity, checks, data, context, run)
    }, [])
  }
  if (context.event === 'DELETE') {
    // we are only interested in table-level references not all derived ones on view levels
    // TODO: why?
    while (entity.query && entity.query._target) {
      entity = csn.definitions[entity.query._target.name]
    }
    result = Object.keys(csn.definitions)
      .filter(
        key =>
          csn.definitions[key].elements !== undefined &&
          // skip check for events, aspects and localized tables
          csn.definitions[key].kind !== 'event' &&
          csn.definitions[key].kind !== 'type' &&
          !csn.definitions[key].name.startsWith('localized.')
      )
      .reduce((deleteResult, key) => {
        return _checkDelete(deleteResult, key, entity, checks, context, csn, run, data)
      }, [])
  }

  if (checks.length) {
    return Promise.all(checks).then(() => {
      return result
    })
  }

  return resolve(result || [])
}

const checkKeys = (entity, data) => {
  if (!Array.isArray(data)) {
    return checkKeys(entity, [data])
  }

  const entityKeys = Object.keys(entity.keys)
  return data.reduce((result, row) => {
    for (const key of entityKeys) {
      if (entityKeys.some(key => row[key] === undefined)) {
        result.push(assertError(ASSERT_NOT_NULL, entity.elements[key]))
      }
    }
    return result
  }, [])
}

module.exports = {
  CDS_TYPE_CHECKS,
  checkComplexType,
  checkStatic,
  checkInputConstraints,
  checkKeys,
  checkReferenceIntegrity,
  assertError,
  ASSERT_DEEP_TO_ONE_ASSOCIATION
}
