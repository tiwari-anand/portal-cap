const generateUUID = require('./uuid')
const { getDBTable, getTransition } = require('./resolveView')

const _generateParentField = (foreignKeyPropagations, row) => {
  if (
    foreignKeyPropagations.parentFieldName &&
    !row[foreignKeyPropagations.parentFieldName] &&
    foreignKeyPropagations.autoGenerate
  ) {
    row[foreignKeyPropagations.parentFieldName] = generateUUID()
  }
}

const _generateChildField = (foreignKeyPropagations, childRow) => {
  if (!childRow[foreignKeyPropagations.childFieldName] && foreignKeyPropagations.autoGenerate) {
    childRow[foreignKeyPropagations.childFieldName] = generateUUID()
  }
}

const _propagateToChid = (foreignKeyPropagations, row, childRow) => {
  if (foreignKeyPropagations.parentFieldName) {
    childRow[foreignKeyPropagations.childFieldName] = row[foreignKeyPropagations.parentFieldName]
  } else if (foreignKeyPropagations.val) childRow[foreignKeyPropagations.childFieldName] = foreignKeyPropagations.val
}

const _propagateToParent = (foreignKeyPropagations, childRow, row) => {
  row[foreignKeyPropagations.parentFieldName] = childRow[foreignKeyPropagations.childFieldName]
}

const propagateForeignKeys = (tKey, row, foreignKeyPropagations) => {
  const childRows = Array.isArray(row[tKey]) ? row[tKey] : [row[tKey]]
  for (const childRow of childRows) {
    if (!childRow) return
    for (const foreignKeyPropagation of foreignKeyPropagations) {
      if (foreignKeyPropagation.fillChild) {
        _generateParentField(foreignKeyPropagation, row)
        _propagateToChid(foreignKeyPropagation, row, childRow)
      } else {
        _generateChildField(foreignKeyPropagation, childRow)
        _propagateToParent(foreignKeyPropagation, childRow, row)
      }
    }
  }
}

const _getSubOns = on => {
  // this only works for on conds with `and`, once we support `or` this needs to be adjusted
  const newOn = on.filter(e => e !== '(' && e !== ')')
  const subOns = []
  let currArr = []
  for (const onEl of newOn) {
    if (currArr.length === 0) subOns.push(currArr)
    if (onEl !== 'and') currArr.push(onEl)
    else {
      currArr = []
    }
  }
  for (const subOn of subOns) {
    // We don't support anything else than
    // A = B AND C = D AND ...
    if (subOn.length !== 3) return []
  }
  return subOns
}

const _parentOfParentKeys = (keys, key, skipForbiddenViewCheck) => {
  const parentOfParent = key._target
  const _keysOfParentOfParent = _keysOfAncestors(parentOfParent, skipForbiddenViewCheck)
  for (const _keyOfParentOfParent of _keysOfParentOfParent) {
    keys.push({
      name: `${key.name}_${_keyOfParentOfParent.name}`,
      autoGenerate: _keyOfParentOfParent.autoGenerate,
      parentFieldName: `${key.name}_${_keyOfParentOfParent.name}`
    })
  }
}

const _parentFieldName = (key, parent, skipForbiddenViewCheck) => {
  let parentFieldName = key.name
  const transition = getTransition(parent, undefined, skipForbiddenViewCheck)
  if (transition) {
    for (const [_key, _val] of transition.mapping) {
      if (_val.value === key.name) {
        parentFieldName = _key
        break
      }
    }
  }
  return parentFieldName
}

const _keysOfAncestors = (parent, skipForbiddenViewCheck, resolveView = true) => {
  const resolved = resolveView ? getDBTable(parent) : parent
  const keys = []
  for (const keyName of Object.keys(resolved.keys)) {
    if (keyName === 'IsActiveEntity') continue
    const key = resolved.keys[keyName]
    if (key.type === 'cds.Association') {
      _parentOfParentKeys(keys, key, skipForbiddenViewCheck)
    } else {
      if (key['@odata.foreignKey4']) continue // ignore generated key property as already added
      const parentFieldName = _parentFieldName(key, parent, skipForbiddenViewCheck)
      keys.push({
        parentFieldName,
        name: key.name,
        autoGenerate: _autoGenerate(key)
      })
    }
  }
  return keys
}

const _autoGenerate = el => el.type === 'cds.UUID' && el.key

const _parentFieldsFromSimpleOnCond = (element, subOn, skipForbiddenViewCheck) => {
  const idxChildField = subOn.findIndex(o => o.ref && o.ref[0] === element.name)
  if (idxChildField === -1) return
  const childFieldName = subOn[idxChildField].ref && subOn[idxChildField].ref[1]
  const childElement = element._target.elements[childFieldName]
  const idxParentField = idxChildField === 2 ? 0 : 2
  if (subOn[1] !== '=') return
  const parentRef = subOn[idxParentField].ref
  if (!childElement.on && parentRef && parentRef.length === 1) {
    return _foreignKeyPropagationsFromToManyOn(element, parentRef, childFieldName, skipForbiddenViewCheck)
  } else if ('val' in subOn[idxParentField]) {
    return _foreignKeyPropagationsFromStaticOn(childFieldName, idxParentField, subOn)
  }
  if (childElement.type === 'cds.Association' && childElement.on) {
    return _foreignKeyPropagationsFromCustomBacklink(element, childElement)
  }
}

const _foreignKeyPropagationsFromStaticOn = (childFieldName, idxParentField, subOn) => {
  if (childFieldName) {
    return [{ fillChild: true, val: subOn[idxParentField].val, childFieldName }]
  }
}

const _foreignKeyPropagationsFromToManyOn = (element, parentRef, childFieldName, skipForbiddenViewCheck) => {
  const parentFieldName = parentRef[0]
  return parentFieldName === '$self'
    ? _keysOfAncestors(element.parent, skipForbiddenViewCheck).map(key => ({
      fillChild: true,
      childFieldName: `${childFieldName}_${key.name}`,
      parentFieldName: key.parentFieldName,
      autoGenerate: key.autoGenerate
    }))
    : [
      {
        fillChild: true,
        childFieldName,
        parentFieldName,
        autoGenerate: _autoGenerate(element.parent.elements[parentFieldName])
      }
    ]
}

const _foreignKeyPropagationsFromCustomBacklink = (element, childElement) => {
  const foreignKeyPropagations = []
  const subOns = _getSubOns(childElement.on)
  for (const subOn of subOns) {
    if (subOn[1] === '=') {
      const parentFieldIdx = subOn.findIndex(o => o.ref && o.ref[0] === childElement.name)
      const otherFieldIdx = parentFieldIdx === 0 ? 2 : 0
      const otherField = subOn[otherFieldIdx]
      if (otherField.ref && otherField.ref.length === 1) {
        const parentFieldName = subOn[parentFieldIdx].ref[1]
        foreignKeyPropagations.push({
          fillChild: true,
          parentFieldName,
          childFieldName: otherField.ref[0],
          autoGenerate: _autoGenerate(element.parent.elements[parentFieldName])
        })
      }
    }
  }
  return foreignKeyPropagations
}

const _foreignKeyPropagationsFromOn = (element, on, skipForbiddenViewCheck) => {
  const subOns = _getSubOns(on)

  const foreignKeyPropagations = []
  for (const subOn of subOns) {
    const subParentFields = _parentFieldsFromSimpleOnCond(element, subOn, skipForbiddenViewCheck)
    if (subParentFields) foreignKeyPropagations.push(...subParentFields)
  }
  return foreignKeyPropagations
}

const foreignKeyPropagations = (element, skipForbiddenViewCheck, resolveView = true) => {
  if (element.is2many && element.on) {
    const foreignKeyPropagations = _foreignKeyPropagationsFromOn(element, element.on, skipForbiddenViewCheck)
    return foreignKeyPropagations.length && foreignKeyPropagations
  }

  if (element.is2one) {
    const target = element._target
    if (!element.on) {
      const ancestorKeys = Object.values(_keysOfAncestors(target, skipForbiddenViewCheck, resolveView))
      const foreignKeyPropagations = ancestorKeys.map(key => ({
        childFieldName: key.name,
        autoGenerate: key.autoGenerate,
        parentFieldName: `${element.name}_${key.name}`
      }))
      return foreignKeyPropagations.length && foreignKeyPropagations
    } else {
      // It's a link through a backlink
      const foreignKeyPropagations = _foreignKeyPropagationsFromOn(element, element.on, skipForbiddenViewCheck)
      return foreignKeyPropagations.length && foreignKeyPropagations
    }
  }
}

module.exports = {
  foreignKeyPropagations,
  propagateForeignKeys
}
