const cds = global.cds || require('@sap/cds/lib')

let LOG
let _event

const getError = require('../error')

const _inverseTransition = transition => {
  const inverseTransition = {}
  inverseTransition.target = transition.queryTarget
  inverseTransition.queryTarget = transition.target
  inverseTransition.mapping = new Map()

  if (!transition.mapping.size) inverseTransition.mapping = new Map()

  for (const [key, value] of transition.mapping) {
    const mapped = {}
    if (value.ref) {
      mapped.ref = [key]
      if (value.transition) mapped.transition = _inverseTransition(value.transition)
      inverseTransition.mapping.set(value.ref[0], mapped)
    }
  }
  return inverseTransition
}

const revertData = (data, transition) => {
  if (!transition || !transition.mapping.size) return data
  const inverseTransition = _inverseTransition(transition)
  return Array.isArray(data)
    ? data.map(entry => _newData(entry, inverseTransition, true))
    : _newData(data, inverseTransition, true)
}

const _newSubData = (newData, key, transition, el, inverse) => {
  const val = newData[key]
  if ((!Array.isArray(val) && typeof val === 'object') || (Array.isArray(val) && val.length !== 0)) {
    const subQueryTarget = el._target
    let mapped = transition.mapping.get(key)
    if (!mapped) {
      mapped = {}
      transition.mapping.set(key, mapped)
    }
    if (!mapped.transition) {
      const subTransition = getTransition(subQueryTarget)
      mapped.transition = inverse ? _inverseTransition(subTransition) : subTransition
    }
    if (Array.isArray(val)) {
      newData[key] = val.map(singleVal => _newData(singleVal, mapped.transition, inverse))
    } else {
      newData[key] = _newData(val, mapped.transition, inverse)
    }
  }
}

const _newData = (data, transition, inverse) => {
  const newData = { ...data }
  const queryTarget = transition.queryTarget

  for (const key of Object.keys(newData)) {
    const el = queryTarget && queryTarget.elements && queryTarget.elements[key]
    if (el && (el.type === 'cds.Composition' || el.type === 'cds.Association')) {
      _newSubData(newData, key, transition, el, inverse)
    }

    const mapped = transition.mapping.get(key)
    if (mapped && mapped.ref) {
      const value = newData[key]
      delete newData[key]
      newData[mapped.ref[0]] = value
    }
  }
  return newData
}

const _newColumns = (columns, transition, withAlias = false) => {
  const newColumns = []
  ;(columns || []).forEach(column => {
    const mapped = column.ref && transition.mapping.get(column.ref[0])
    if (mapped && mapped.ref) {
      const newColumn = { ...column }
      if (withAlias) {
        newColumn.as = column.ref[0]
      }
      newColumn.ref = mapped.ref
      newColumns.push(newColumn)
    } else if (mapped && mapped.val) {
      const newColumn = {}
      newColumn.as = column.ref[0]
      newColumn.val = mapped.val
      newColumns.push(newColumn)
    } else {
      newColumns.push(column)
    }
  })
  return newColumns
}

const _newInsertColumns = (columns, transition) => {
  const newColumns = []
  ;(columns || []).forEach(column => {
    const mapped = transition.mapping.get(column)
    if (mapped && mapped.ref) {
      newColumns.push(mapped.ref[0])
    } else if (!mapped) {
      newColumns.push(column)
    }
  })
  return newColumns
}

const _newEntries = (entries, transition) => {
  const newEntries = []
  ;(entries || []).forEach(entry => {
    newEntries.push(_newData(entry, transition))
  })
  return newEntries
}

const _newWhere = (where, transition) => {
  const newWhere = []
  ;(where || []).forEach(whereElement => {
    const mapped = whereElement.ref && transition.mapping.get(whereElement.ref[0])
    if (mapped && mapped.ref) {
      const newWhereElement = { ...whereElement }
      newWhereElement.ref = mapped.ref
      newWhere.push(newWhereElement)
    } else if (!mapped) {
      newWhere.push(whereElement)
    }
  })
  return newWhere
}

const isAssocOrComp = element => {
  return element.type === 'cds.Association' || element.type === 'cds.Composition'
}

const _initialColumns = transition => {
  const columns = []
  for (const [transitionEl] of transition.mapping) {
    // REVISIT: structured elements
    if (
      !transition.queryTarget.elements[transitionEl] ||
      isAssocOrComp(transition.queryTarget.elements[transitionEl])
    ) {
      continue
    }
    columns.push({ ref: [transitionEl] })
  }
  return columns
}

const _rewriteQueryPath = (path, transitions) => {
  return path.ref.map((f, i) => {
    if (i === 0) {
      const target = transitions[0].target
      if (typeof f === 'string') {
        return target.name
      }
      if (f.id) {
        return {
          id: target.name,
          where: _newWhere(f.where, transitions[0])
        }
      }
    } else {
      if (typeof f === 'string') {
        const transitionMapping = transitions[i - 1].mapping.get(f)
        return (transitionMapping && transitionMapping.ref && transitionMapping.ref[0]) || f
      }
      if (f.id) {
        const transitionMapping = transitions[i - 1].mapping.get(f.id)
        return {
          id: (transitionMapping && transitionMapping.ref && transitionMapping.ref[0]) || f.id,
          where: _newWhere(f.where, transitions[i])
        }
      }
    }
  })
}

const _newUpdate = (query, transitions) => {
  const targetTransition = transitions[transitions.length - 1]
  const targetName = targetTransition.target.name
  const newUpdate = { ...query.UPDATE }
  newUpdate.entity = newUpdate.entity.ref
    ? { ...newUpdate.entity, ...{ ref: _rewriteQueryPath(query.UPDATE.entity, transitions) } }
    : targetName
  if (newUpdate.data) newUpdate.data = _newData(newUpdate.data, targetTransition)
  if (newUpdate.with) newUpdate.with = _newData(newUpdate.with, targetTransition)
  if (newUpdate.where) newUpdate.where = _newWhere(newUpdate.where, targetTransition)
  Object.defineProperty(newUpdate, '_transitions', { enumerable: false, value: transitions })
  return newUpdate
}

const _newSelect = (query, transitions) => {
  const targetTransition = transitions[transitions.length - 1]
  const newSelect = { ...query.SELECT }
  newSelect.from = { ...newSelect.from, ...{ ref: _rewriteQueryPath(query.SELECT.from, transitions) } }
  if (!newSelect.columns && targetTransition.mapping.size) newSelect.columns = _initialColumns(targetTransition)
  if (newSelect.columns) newSelect.columns = _newColumns(newSelect.columns, targetTransition, true)
  if (newSelect.having) newSelect.having = _newColumns(newSelect.having, targetTransition)
  if (newSelect.groupBy) newSelect.groupBy = _newColumns(newSelect.groupBy, targetTransition)
  if (newSelect.orderBy) newSelect.orderBy = _newColumns(newSelect.orderBy, targetTransition)
  if (newSelect.where) newSelect.where = _newWhere(newSelect.where, targetTransition)
  Object.defineProperty(newSelect, '_transitions', { enumerable: false, value: transitions })
  return newSelect
}

const _newInsert = (query, transitions) => {
  const targetTransition = transitions[transitions.length - 1]
  const targetName = targetTransition.target.name
  const newInsert = { ...query.INSERT }
  newInsert.into = newInsert.into.ref
    ? { ...newInsert.into, ...{ ref: _rewriteQueryPath(query.INSERT.into, transitions) } }
    : targetName
  if (newInsert.columns) newInsert.columns = _newInsertColumns(newInsert.columns, targetTransition)
  if (newInsert.entries) newInsert.entries = _newEntries(newInsert.entries, targetTransition)
  Object.defineProperty(newInsert, '_transitions', { enumerable: false, value: transitions })
  return newInsert
}

const _newDelete = (query, transitions) => {
  const targetTransition = transitions[transitions.length - 1]
  const targetName = targetTransition.target.name
  const newDelete = { ...query.DELETE }
  newDelete.from = newDelete.from.ref
    ? { ...newDelete.from, ...{ ref: _rewriteQueryPath(query.DELETE.from, transitions) } }
    : targetName
  if (newDelete.where) newDelete.where = _newWhere(newDelete.where, targetTransition)
  Object.defineProperty(newDelete, '_transitions', { enumerable: false, value: transitions })
  return newDelete
}

// Find aliased column from the projection and set it as ref
const _renameColumns = (query, columns) => {
  for (const col of query.SELECT.columns) {
    if (typeof col === 'object' && col.ref && col.as && col.ref[0] !== col.as) {
      for (const initCol of columns) {
        if (initCol.ref && initCol.ref[0] === col.as) {
          initCol.ref[0] = col.ref[0]
          continue
        }
      }
    }
  }
}

const _merge = (array1, array2) => {
  const merged = []
  for (const el1 of array1) {
    if (!array2.some(el2 => el2.ref && el1.ref && el2.ref[0] === el1.ref[0])) merged.push(el1)
  }
  return [...merged, ...array2]
}

const _starColumns = elements => Object.keys(elements).map(element => ({ ref: [element] }))

const _mappedValue = col => {
  const key = col.as || col.ref[0]
  const val = col.ref ? { ref: col.ref } : { val: col.val }
  return [key, val]
}

/**
 * If no entity definition is found, no transition is done.
 * @param queryTargetName
 */
const getTransition = (queryTarget, force, skipForbiddenViewCheck) => {
  // Never resolve unknown targets (e.g. for drafts)
  if (!queryTarget || (queryTarget.hasOwnProperty('@cds.persistence.table') && !force)) {
    return { target: queryTarget, queryTarget, mapping: new Map() }
  }
  const { target: _target, transitionColumns } = _getTransitionData(queryTarget, [], force, skipForbiddenViewCheck)
  const mapping = new Map(transitionColumns.map(key => _mappedValue(key)))
  return { target: _target, queryTarget, mapping }
}

// Don't check for table in case of external services (-> force)
// Reason for hasOwnProperty: All projections have target in their prototype
// Revisit: Check if this is really intended
const _isProjection = (target, force) =>
  target.query && target.query._target && (force || !target.hasOwnProperty('@cds.persistence.table'))

const getDBTable = (target, force) => {
  if (_isProjection(target, force)) {
    return getDBTable(target.query._target, force)
  }
  return target
}

const _includeForeignKeys = (columns, target) => {
  for (const column of target.query.SELECT.columns) {
    const columnName = column.ref && column.ref[0]
    if (columnName && column.as) {
      const el = target.elements[column.as]
      if (el && el.type === 'cds.Association' && el.keys) {
        for (const rootKeys of el.keys) {
          // REVISIT: Check if this also works for deeply nested ones
          const rootKeyName = rootKeys.ref && rootKeys.ref[0]
          columns.push({ ref: [`${columnName}_${rootKeyName}`], as: `${el.name}_${rootKeyName}` })
        }
      }
    }
  }
}

const _checkForForbiddenViews = queryTarget => {
  const select = queryTarget && queryTarget.query && queryTarget.query.SELECT
  if (select) {
    if (!select.from || select.from.join || select.from.length > 1) {
      throw getError({
        code: 501,
        message: 'NON_WRITABLE_VIEW',
        target: queryTarget.name,
        args: [_event || 'INSERT|UPDATE|DELETE']
      })
    }
    if (select.where) {
      LOG &&
        LOG._debug &&
        LOG.debug(`Ignoring where clause during ${_event || 'INSERT|UPDATE|DELETE'} on view "${queryTarget.name}"`)
    }
  }
}

const _getTransitionData = (target, columns, force, skipForbiddenViewCheck) => {
  // REVISIT: Find less param polluting way to skip forbidden view check for reads
  if (!skipForbiddenViewCheck) _checkForForbiddenViews(target)

  if (target.query && target.query.SELECT && target.query.SELECT.columns) {
    if (!columns.length) {
      // REVISIT: Filter out calculated fields
      const plainColumns = target.query.SELECT.columns.filter(c => c !== '*')
      _includeForeignKeys(columns, target)
      if (target.query.SELECT.columns.some(c => c === '*') && target.query._target) {
        const starColumns = _starColumns(target.query._target.elements)
        columns.push(..._merge(starColumns, plainColumns))
      } else {
        columns.push(...plainColumns)
      }
    }
    _renameColumns(target.query, columns)
  }

  if (_isProjection(target, force)) {
    return _getTransitionData(target.query._target, columns, force, skipForbiddenViewCheck)
  }

  return { target, transitionColumns: columns }
}

const _entityTransitionsForTarget = (from, model, force) => {
  let previousEntity
  if (typeof from === 'string') {
    return model.definitions[from] && [getTransition(model.definitions[from], force)]
  }

  return from.ref.map((f, i) => {
    const element = f.id || f
    if (i === 0) {
      const entity = model.definitions[element]
      if (entity) {
        previousEntity = entity
        return getTransition(entity, force)
      }
    }
    if (previousEntity) {
      const entity = previousEntity.elements[element] && previousEntity.elements[element]._target
      if (entity) {
        previousEntity = entity
        return getTransition(entity, force)
      }
    }
  })
}

const resolveView = (query, model, component, force) => {
  LOG = (cds.log || cds.debug)(component)

  // If the query is a projection, one must follow it
  // to let the underlying service know its true entity.

  const newQuery = {}
  Object.setPrototypeOf(newQuery, query)
  if ('UPDATE' in newQuery) {
    const transitions = _entityTransitionsForTarget(query.UPDATE.entity, model, force)
    newQuery.UPDATE = _newUpdate(newQuery, transitions)
    _event = 'UPDATE'
    return newQuery
  }
  if ('SELECT' in newQuery) {
    const transitions = _entityTransitionsForTarget(query.SELECT.from, model, force)
    newQuery.SELECT = _newSelect(newQuery, transitions)
    _event = 'SELECT'
    return newQuery
  }
  if ('INSERT' in newQuery) {
    const transitions = _entityTransitionsForTarget(query.INSERT.into, model, force)
    newQuery.INSERT = _newInsert(newQuery, transitions)
    _event = 'INSERT'
    return newQuery
  }
  if ('DELETE' in newQuery) {
    const transitions = _entityTransitionsForTarget(query.DELETE.from, model, force)
    newQuery.DELETE = _newDelete(newQuery, transitions)
    _event = 'DELETE'
    return newQuery
  }
}

module.exports = {
  getDBTable,
  resolveView,
  getTransition,
  revertData
}
