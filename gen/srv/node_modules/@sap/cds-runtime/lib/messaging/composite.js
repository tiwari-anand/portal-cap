const cds = global.cds || require('@sap/cds/lib')

const _globToRegExp = string => {
  if (!string) return string
  const star = '<star_placeholder>'
  const starRegExp = new RegExp(star, 'g')
  let stringRegExp = string.replace(/\?/g, '.')
  stringRegExp = stringRegExp.replace(/\*\*/g, '.' + star)
  stringRegExp = stringRegExp.replace(/\*/g, '[^/]*')
  return stringRegExp.replace(starRegExp, '*')
}

const _delegate = (fn, args, serviceName) => {
  const child = cds.services[serviceName] // already connected in init
  return child[fn](...args)
}

// TODO: Match entity
const _delegateAll = (fn, args, { event }, normalizedRoutes) => {
  return Promise.all(
    Object.keys(normalizedRoutes).map(async serviceName => {
      const patterns = normalizedRoutes[serviceName]
      for (const pattern of patterns) {
        if (event.match(pattern.event)) {
          return _delegate(fn, args, serviceName)
        }
      }
    })
  )
}

const _normalizeRoutes = (routes = {}) => {
  return Object.keys(routes).reduce((res, curr) => {
    const channels = routes[curr].map(route => {
      if (typeof route === 'string') return { event: _globToRegExp(route) }
      if (typeof route === 'object') {
        return { event: _globToRegExp(route.event), entity: _globToRegExp(route.entity) }
      }
    })
    res[curr] = channels
    return res
  }, {})
}

class Composite extends cds.Service {
  init () {
    this.normalizedRoutes = _normalizeRoutes(this.options.routes)
    return Promise.all(
      Object.keys(this.normalizedRoutes || {}).map(serviceName => {
        return cds.connect.to(serviceName)
      })
    )
  }
  subscribe (...args) {
    const event = args[1]
    const handler = args[3]
    return _delegateAll('on', [event, handler], { event }, this.normalizedRoutes)
  }
  dispatch (...args) {
    const event = args[0].event
    return _delegateAll('emit', args, { event }, this.normalizedRoutes)
  }
}
module.exports = Composite
