// Custom resolve functionality for the CDS compiler
//
// See `internalDoc/ModuleResolution.md` for details on the algorithm.
// The algorithm is based on NodeJS's `require()`.

'use strict';

const path = require('path');
const fs = require('fs');

const DEFAULT_ENCODING = 'utf-8';

/**
 * Resolve the given path according to NodeJS's rules for `require()`.
 *
 * We use the interface of the NodeJS package `resolve` for compatibility
 * with existing code.  This may change at a later point.
 *
 * @param {string} moduleName Module to load, e.g. `./Include.cds` or `@sap/cds/common`.
 * @param {ResolveOptions} options
 * @param {(err, result) => void} callback
 */
function resolveCDS(moduleName, options, callback) {
  const isWindows = (process.platform === 'win32');
  let resolvedBaseDir = path.resolve(options.basedir);

  // NodeJS does not preserve symbolic links when resolving modules.
  // So neither do we.
  fs.realpath(resolvedBaseDir, (realPathErr, realPath) => {
    // There may be an error in resolving the symlink.
    // We ignore the error and simply use the original path.
    // Otherwise cds-lsp tests would fail because they don't have real
    // files in their tests.
    if (!realPathErr)
      resolvedBaseDir = realPath;
    load();
  });

  function load() {
    if (isLocalFile(moduleName))
      loadFromLocalFileOrDirectory();
    else
      loadNodeModules(resolvedBaseDir);
  }

  /**
   * The module is local and not a in a node_module directory.
   * Try to load it as a file or directory.
   */
  function loadFromLocalFileOrDirectory() {
    // Also handles absolute file paths.
    const withBase = path.resolve(resolvedBaseDir, moduleName);
    // If the local moduleName ends with a slash (or references the sub-directory)
    // it is a good indicator that we want to load a directory and we save some
    // file lookups.  Slashes cannot be used in filenames (both *nix and Windows).
    // Shortcut to 2b)
    if (moduleName === '..' || moduleName.endsWith('/'))
      loadAsDirectory(withBase, callback);
    else
      loadAsLocalFileOrDirectory(withBase, callback);
  }

  /**
   * Combines LOAD_AS_FILE() and LOAD_AS_DIRECTORY() from our specification.
   * If no file can be found, it tries to load the moduleName as a directory,
   * i.e. tries to load a `package.json`, etc.
   *
   * @param {string} absoluteModulePath
   * @param {(err, filepath: string|null) => void} cb
   */
  function loadAsLocalFileOrDirectory(absoluteModulePath, cb) {
    loadAsFile(absoluteModulePath, (err, filepath) => {
      if (!err && filepath)
        cb(null, filepath);
      else
        loadAsDirectory(absoluteModulePath, cb);
    });
  }

  /**
   * Try to load the module from absoluteModulePath with different extensions.
   * Instead of the hard-coded extensions, we use the ones supplied by `options.extensions`.
   *
   * @param {string} absoluteModulePath
   * @param {(err, filepath: string|null) => void} cb
   */
  function loadAsFile(absoluteModulePath, cb) {
    const extensionsToTry = [ '' ].concat(options.extensions);
    loadFileWithExtensions(extensionsToTry);

    /**
     * Tries to load `absoluteModulePath` with the given extensions one after another.
     *
     * @param {string[]} exts The extensions to try. Loaded in the order of the array.
     */
    function loadFileWithExtensions(exts) {
      if (exts.length === 0) {
        // If we reach this point then no file with the given extensions could be found.
        cb(makeNotFoundError(), null);
        return;
      }
      const file = absoluteModulePath + exts.shift();
      options.isFile(file, (err, foundAndIsFile) => {
        if (!err && foundAndIsFile)
          cb(null, file);
        else
          loadFileWithExtensions(exts);
      });
    }
  }

  /**
   * Load the module as a directory, i.e. use either the main entry of `package.json`
   * in the directory or an index.ext file.
   *
   * @param {string} absoluteModulePath
   * @param {(err, filepath: string|null) => void} cb
   */
  function loadAsDirectory(absoluteModulePath, cb) {
    loadAndParsePackageJsonInDirectory(absoluteModulePath, (packageErr, packageJson) => {
      // TODO: options.packageFilter() does the `cds.main` lookup at the moment.
      //       Move it here when the resolve() package is removed.
      const validMainEntry = packageJson && (typeof packageJson.main === 'string');
      if (packageErr || !validMainEntry) {
        loadIndex();
        return;
      }
      loadMain(packageJson.main);
    });

    function loadMain(main) {
      const file = path.join(absoluteModulePath, main);
      loadAsFile(file, (fileErr, filePath) => {
        if (!fileErr && filePath)
          cb(null, filePath);
        else
          loadIndex();
      });
    }

    function loadIndex() {
      const filename = 'index';
      const file = path.join(absoluteModulePath, filename);
      loadAsFile(file, (fileErr, filePath) => {
        if (!fileErr && filePath)
          cb(null, filePath);
        else
          cb(makeNotFoundError(), null);
      });
    }
  }

  /**
   * Try to load the module from a node_modules directory.
   * Start at absoluteDir and go through all parent directories.
   *
   * @param {string} absoluteDir
   */
  function loadNodeModules(absoluteDir) {
    const dirs = nodeModulesPaths(absoluteDir);
    loadFromNodeDirs(dirs);

    function loadFromNodeDirs(nodeDirs) {
      const dir = nodeDirs.shift();
      if (!dir) {
        // We're at root
        callback(makeNotFoundError(), null);
        return;
      }
      const file = path.join(dir, moduleName);
      loadAsLocalFileOrDirectory(file, (err, filepath) => {
        if (!err && filepath)
          callback(null, filepath);
        else
          loadFromNodeDirs(nodeDirs);
      });
    }
  }

  /**
   * Try to load the package.json from the given directory.
   * Is only successful if the file can be read and parsed by JSON.parse().
   * Applies options.packageFilter on the package.json.
   *
   * @param {string} packageDir
   * @param {(err, json) => void} cb
   */
  function loadAndParsePackageJsonInDirectory(packageDir, cb) {
    const file = path.join(packageDir, 'package.json');

    options.readFile(file, DEFAULT_ENCODING, (err, content) => {
      if (err) {
        cb(err, null);
        return;
      }
      try {
        const json = JSON.parse(content);
        cb(null, options.packageFilter(json));
      }
      catch (parseErr) {
        cb(parseErr, null);
      }
    });
  }

  /**
   * Get a list of all `node_modules` directories that MAY exist.
   * Starting from absoluteStart upwards until at root.
   *
   * @param {string} absoluteStart
   * @returns {string[]} Array of possible "node_modules" folders for the given path.
   */
  function nodeModulesPaths(absoluteStart) {
    // Use platform-dependent separator.  All NodeJS `path` methods use the system's path separator.
    const parts = absoluteStart.split(path.sep);
    // Do NOT use global node_modules directories.
    const dirs = [];

    // If we're on *nix systems, the first part is just an empty string ''
    // because the path is absolute.  Re-add it here because `path.join()`
    // ignores empty segments which would result in a relative path.
    if (!isWindows && parts.length > 0 && parts[0] === '')
      parts[0] = '/';

    for (let i = parts.length - 1; i >= 0; i--) {
      if (parts[i] === 'node_modules')
        continue;
      const dir = path.join(...parts.slice(0, i + 1), 'node_modules');
      dirs.push(dir);
    }
    return dirs;
  }

  /**
   * Create a not found error that can be passed to the caller.
   *
   * @returns {Error}
   */
  function makeNotFoundError() {
    const moduleError = new Error(`Cannot find module '${ moduleName }' from '${ options.basedir }'`);
    moduleError.code = 'MODULE_NOT_FOUND';
    return moduleError;
  }
}

/**
 * Returns true if the given module name is a local file.
 *
 * @param {string} moduleName
 */
function isLocalFile(moduleName) {
  // Starts with or is equal to '..'
  // Starts with '/'
  // Starts with 'C:/' or 'C:\'
  return (/^(\.\.?(\/|$)|\/|(\w:)?[/\\])/).test(moduleName);
}

/**
 * Pre-process package.json contents before passing it to resolve().
 *
 * @todo Remove / merge with resolveCDS() when resolve package is removed.
 * @param {object} pkg
 */
function packageFilter( pkg ) {
  return { main: pkg.cds && pkg.cds.main || pkg.main };
}

/**
 * Default lookup-extensions.  If a module "./index" is requested, then
 * "./index.cds" is checked first, then "index.csn" and so on.
 */
const extensions = [ '.cds', '.csn', '.csn.json', '.json' ];

/**
 * @typedef {object} ResolveOptions
 * @property {string} basedir
 * @property {string[]} extensions
 * @property {(pkg: string) => void} packageFilter Process the given package.json object.
 *   Return value must have a `main` field.
 * @property {(path: string, callback: (err, foundAndIsFile) => void) => void} isFile
 * @property {(path: string, encoding, callback: (err, content) => void) => void} readFile Function
 *   used to read `package.json` files.
 */

module.exports = {
  resolveCDS,
  isLocalFile,
  packageFilter,
  extensions,
};
